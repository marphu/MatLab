function OscillAnalize(varargin)
% Функция анализа оссцилограмм
% Входящие данные номер осцилограммы
% В случае отсутствия номера запускается отладочный режим работы
% с выделеным сигналом.
%
% Глобализация основных переменных
global A Odin
% Проверка типа запуска
if isempty(varargin)
    n=241;
    Odin = true;
else
    n=varargin{1};
    Odin = false;
    %     display(n);
end
% Если нет осцилограмм, то загрузка осцилограмм
if isfield(A(n),'data')
    if isempty(A(n).data)
        LoadDir
    end
else
    return;
end
% display(A(n).name);
% % Отладочная заглушка
% Odin = false;
% P = [-3.9490 1.3505];
% Поиск начальной точки
A(n).StartPoint = FindStart(A(n).data);
% Округления значения начальной точки до ближайшего (нужно ли?!)
A(n).StartPoint = round(A(n).StartPoint*A(n).rate)/A(n).rate;
% количество точек для сглаживания
Num=1;
% если отладка - то построить графики токов со смещением начальной точки
if Odin
    % Постоение графиков тока
    plot(A(n).data(:,1)-A(n).StartPoint,smooth(A(n).data(:,2),Num))
    hold all
%     plot(A(n).data(:,1)-A(n).StartPoint,smooth(A(n).data(:,3),Num))
%     plot(A(n).data(:,1)-A(n).StartPoint,smooth(A(n).data(:,4),Num))
end
% Определение типа осцилограммы и моментов замыкания/размыкания ГК
[type, Open, Close, A(n).Dreb, A(n).BK] = SelectType(A(n));
% Сохранение типа осцилограммы в общую структуру
A(n).type = type;
% Введение поправки на смещение для размыкания
for k=1:length(Open)
    Open{k}=Open{k}-A(n).StartPoint;
end
% Введение поправки на смещение для замыкания
for k=1:length(Close)
    Close{k}=Close{k}-A(n).StartPoint;
end
% Сохранение моментов размыкания ГК в общую структуру
A(n).Open = Open;
% Сохранение моментов замыкания ГК в общую структуру
A(n).Close = Close;
% Определение схемы включения
[A(n).On, A(n).Off] = SchemeImp(A(n));
% Если это импульс включения без дребезга - то поиск момента замыкания МС
if type == [1, 1, 1, 1] %#ok;
    % Поиск моментов замыкания для фазы А
    [tA, IA] = FindZam(A(n).data(:,[1 2]), ...
        A(n).StartPoint, A(n).On, A(n).Off);
    % То же для фазы В
%     [tB, IB] = FindZam(A(n).data(:,[1 3]),...
%         A(n).StartPoint, A(n).On, A(n).Off);
    % То же для фазы С
%     [tC, IC] = FindZam(A(n).data(:,[1 4]),...
%         A(n).StartPoint, A(n).On, A(n).Off);
%     if Odin
%         % Plot MS Close
%         % Отображение результатов на графике
%         plot(tA-A(n).StartPoint,IA,'bv')
%         plot(tB-A(n).StartPoint,IB,'gv')
%         plot(tC-A(n).StartPoint,IC,'rv')
%     end
    % Сохранение в общую структуру результатов
    A(n).Za = [tA-A(n).StartPoint;IA];
%     A(n).Zb = [tB-A(n).StartPoint;IB];
%     A(n).Zc = [tC-A(n).StartPoint;IC];
    if Odin
        % Построение графика напряжения деленого на 100
        plot(A(n).data(:,1)-A(n).StartPoint,...
            smooth(A(n).data(:,7),Num)/100,...
            'k');
    end
    % Поиск максимумов осцилограмм пофазно
    TAm = FindMax(A(n).data(:,1),A(n).data(:,2), A(n).On, ...
        A(n).Off, A(n).StartPoint);
%     TBm = FindMax(A(n).data(:,1),A(n).data(:,3), A(n).On, ...
%         A(n).Off,A(n).StartPoint);
%     TCm = FindMax(A(n).data(:,1),A(n).data(:,4), A(n).On, ...
%         A(n).Off,A(n).StartPoint);
    % Задания массива характерных точек. Предполагалось, что их будет 5, а
    % получилось 6. Это точки:
    % 1. Момент отключения первого импульса
    % 2. Момент включения вторго импульса
    % 3. Второй максимум тока
    % 4. Момент замыкания МС
    % 5. Последний максимум тока
    % 6. Момент отключения вторго импульса
    % Все эти времена пофазно
    TAm=[A(n).Off(1), A(n).On(2), TAm(1), A(n).Za(1), TAm(2),A(n).Off(2)];
%     TBm=[A(n).Off(1), A(n).On(2), TBm(1), A(n).Zb(1), TBm(2),A(n).Off(2)];
%     TCm=[A(n).Off(1), A(n).On(2), TCm(1), A(n).Zc(1), TCm(2),A(n).Off(2)];
    % Пустая матрица соответствующих токов
    IAm=zeros(size(TAm));
    % тоже пофазно
%     IBm = IAm;
    % А фаз то три %)
%     ICm = IAm;
    % Вектор времени
    t=A(n).data(:,1);
    % Частота дискритизации, помогает в рассчетах
    rate = A(n).rate;
    % Стартовая точка буквами
    StartPoint = A(n).StartPoint;
    % Перебор по длинне вектора токов
    for k=1:length(IAm)
        % временная переменная, со сглаженным током фазы А
        tmp=smooth(A(n).data(:,2),5);
        % Выделение токов, соответствующих временому вектору, описанному
        % выше
        IAm(k) = tmp( t == (round((TAm(k) + StartPoint)*rate)/rate));
%         % Тоже для фазы В
%         tmp=smooth(A(n).data(:,3),5);
%         IBm(k) = tmp( t == (round((TBm(k) + StartPoint)*rate)/rate));
%         % Тоже для фазы С
%         tmp=smooth(A(n).data(:,4),5);
%         ICm(k) = tmp( t == (round((TCm(k) + StartPoint)*rate)/rate));
    end
    % Запихивания всего этого безобразия в общую структуру данных
    % Время
    A(n).T5 = TAm;%TBm;TCm];
    % Токи
    A(n).I5 = IAm;%IBm;ICm];
    p = [-3.95 1.35];
    A(n).R = polyval(p,(TAm(5) - TAm(4))*(IAm(5) + IAm(4)));
    % И если это отладочный режим, названный в чесь бога Одина, то
    % построить графики того безобразия, которое мы так долбестно вычисляли
    if Odin
        % И все еще пофазно
        plot(TAm,IAm,'b*');
%         plot(TBm,IBm,'g*');
%         plot(TCm,ICm,'r*');
    end
end
% И если это отключение
if type == [2 2 2 2] %#ok;
    % И стартовая точка соответствуют нулю
    if A(n).StartPoint == 0
        % то это, скорее всего измерения тока размагничивания, и это
        % хороший момент, что бы его вычислить и результатты занести в
        % общую структуру данных
        [A(n).Razm, A(n).Raz3, A(n).First, A(n).RVolt] = Razm(A(n));
    end
end
if A(n).StartPoint > 0
    % Калиброска нуля токовых каналов
    A(n).IAz = ZerroCalibrate(A(n).data(:,1:4),...
        A(n).StartPoint);
end
if Odin
    % Plot Start point
    % Опять таки в жертву Богу Одину график для отладки со стартовой точкой
    plot(0,0,'or','MarkerSize',10)
    % Отключаем наложения графиков
    hold off
    % рисуем няшную сеточку
    grid on
    % И показываем, что мы навычисляли
    display(A(n))
end
end
%% Поиск начальной точки осцилограммы
function t=FindStart(d)
% Функция поиска начальной точки
% Входные дынные:
% d     - Структура данных
% Выходные данные 
%       - Стартовая точка
% Начальный момент - включение любого напряжения. Определяем его по
% абсолютному значению производной сглаженного напряжения больше нуля.
tt = d(abs(diff(smooth(d(:,7))))>10,1);
% Если таких резких моментов не было (например, при измерении тока
% размагничивания), то нулевая точка равна нулю.
if isempty(tt)
    t=0;
else
    % А если были - то первая точка =)
    t=tt(1);
end
end
%% Поиск момента замыкания МС
function [t, It] = FindZam(d, s, On, Off)
% Функция поиска момента смыкания МС
% Выходные данные:
% t     - Момент замыкания
% It    - Ток в момент замыкания
% Входные данные
% d     - матрица данных [время; ток]
% s     - Начальная точка 
% On    - Моменты включения напряжения
% Off   - Моменты выключения напряжения
% Формирования диапазона поиска
IMP = [On(2)+5e-3 Off(2)] ;
% Добавления смещения нулевой точки
IMP=IMP + s;
% Вектор времени
T = d(:,1);
% Вектор тока
Z = d(:,2);
% Сглаживание тока
A = smooth(Z);
% Сглаживание производной тока
B = smooth([0;diff(A)]);
% Перемножения производной на саму себя со сдвигом 1 для определения точек
% пересечения нуля
C =[0;B(1:end-1)].*B ;
% Выделение точек пересечения нуля
TZ=T(C <= 0);
% Точки должны находиться в искомом диапазоне От второго включения
TZ=TZ(TZ > IMP(1));
% до вторго выключения
TZ=TZ(TZ < IMP(2));
% Создание пустого вектора тока
Iz = zeros(size(TZ));
% Перебор моментов минимума
for tz=1:length(TZ)
    % и выявления токов, в эти моменты
    Iz(tz)=Z(T==TZ(tz));
end
% Определение абсолютного минимума из всех найденых и соотв. номера
[It, n] = min(Iz);
% Определение момента абсолютного минимума
t=TZ(n);
end
%% Тип осцилограммы
function [type, Open, Close, Dreb, BK] = SelectType(d)
% Определение типа оссцилограммы и моментов включения/отключения ГК
% Входные данные:
% d     - общая структура данных
% Выходные данные
% type  - тип оссцилограммы
% Open  - Времена размыкания ГК
% Close - времена замыкания ГК
%
% Подробнее о типе . Если нет размыканий, то 1; если нет замыканий, то 2;
% если нет ни того ни того, то 3. В противном случае 0. ТО есть при
% штатном отключении 2, при штатном включении 1, при включении с дребезгом
% 0, а если ничего не происходит (чего по идее быть не может), то 3. Эти
% числа сопаставляются каждой фазе. То есть [1 1 1] - включение, [1 0 1] -
% дребезг на фазе В. и тд

% Состояние ГК пофазно, в частности для фазы А
GKA=d.data(:,3);
% то же для фазы В
GKB=d.data(:,4);
% то же для фазы С
GKC=d.data(:,5);
% 
GKK=d.data(:,6);
% вектор времени
t=d.data(:,1);
% Вычисление производной от состояния ГК
dGKA=[0;diff(GKA)];
% тоже для фазы В
dGKB=[0;diff(GKB)];
% Тоже ддля фазы С
dGKC=[0;diff(GKC)];
% 
dGKK=[0;diff(GKK)];
% Времена, когда контакты замнулись, фаза А
tCA=t(dGKA>1);
% Тоже фаза В
tCB=t(dGKB>1);
% ТОже фаза С
tCC=t(dGKC>1);
tCK=t(dGKK>1);
% Времена, когда контакты разомкнулись, фаза А
tOA=t(dGKA<-1);
% тоже фаза В
tOB=t(dGKB<-1);
% тоже фаза С
tOC=t(dGKC<-1);
tOK=t(dGKK<-1);
% Тип по умолчанию, пофпзно, фаза А
typeA = 0;
% тоже фаза В
typeB = 0;
% Тоже фаза С
typeC = 0;
typeK = 0;
% Определение типа по замыканиям и размыканиям ГК пофазно
if isempty(tOA) && ~isempty(tCA) 
    % если нет размыканий, то это скорее всего включение и потому 1
    typeA = 1;
elseif isempty(tCA) && ~isempty(tOA)
    % Если нет замыканий, то это скорее всего отключение и потому 2
    typeA = 2;
elseif isempty(tOA) && isempty(tCA)
    % Если нет ни того ни того, то это хренькакая-то и потому 3
    typeA = 3;
end
% тот же алгоритм, только для фазы В
if isempty(tOB)  && ~isempty(tCB)
    typeB = 1;
elseif isempty(tCB) && ~isempty(tOB)
    typeB = 2;
elseif isempty(tOB) && isempty(tCB)
    typeB = 3;
end
% тот же алгоритм, только для фазы С
if isempty(tOC) && ~isempty(tCC)
    typeC = 1;
elseif isempty(tCC) && ~isempty(tOC)
    typeC = 2;
elseif isempty(tOC) && isempty(tCC)
    typeC = 3;
end
% тот же алгоритм, только для фазы С
if isempty(tOK) && ~isempty(tCK)
    typeK = 1;
elseif isempty(tCK) && ~isempty(tOK)
    typeK = 2;
elseif isempty(tOK) && isempty(tCK)
    typeK = 3;
end
% Сведения безобразий с типами в один массив
type = [typeA, typeB, typeC, typeK];
% сведение времен отключения в один массив
Open = {tOA;tOB;tOC;tOK};
% Сведение времен включения в один массив
Close = {tCA;tCB;tCC;tCK};
Dreb = [0 0 0 0]';
for k=1:4
    if type(k) == 0
        q=diff(d.data([1 end],k+2));
        type(k) = 3 - sign(abs(q))*(1.5 + 0.5*sign(q));
        OC = sort([Open{k}; Close{k}]);
        Dreb(k) = max(OC) - min(OC);
    end
end
% display(typeA);
if typeA == 2
    if isempty(Open{4})
        BK=1;
    else
        BK = Open{4}(end) - Open{2}(1);
    end
elseif typeA == 1
    if isempty(Close{4})
        BK=2;
    else
        BK = Close{4}(end) - Close{2}(1);
    end
else
    BK=0;
end
end
%% Схема импульсов
function [P, M] = SchemeImp(d)
% Определение схемы импульсов
% Входные данные - элемент структуры с осцилограммой
% Выходные данные:
% Р - моменты включений напряжения
% М - моменты отключений напряжения
% Уровень отсечки
Level = 50;
% Вектор времени
T = d.data(:,1);
% Вектор напряжения для анализа
V = d.data(:,7);
% Вычисление производной напряжения и нормализация длинны вектора
dV = [0; diff(V)];
% Определение моментов включения напряжения
P = T(dV >  Level)';
% Отсеивание близких моментов(ближе 1мс) и сдвиг на начальное время и
% добавление сдвига на несколько отсетов из-за неточностей (на самом деле,
% не заю почему =))
P = P(diff([0 P])>1e-3)-d.StartPoint-2/d.rate;
% То же самое для отключения
M = T(dV < -Level)';
M = M(diff([0 M])>1e-3)-d.StartPoint-2/d.rate;
end
%% Размагничивание
function [II, Iph, F, V] = Razm(d)
% Функция определяет ток расмагничивания
% Входные данные - струтура данныз соответствующего блока
% Выходные:
% II    Суммарный ток рамагничивания
% Iph   Пофазный ток рамагничивания
% F     Фаза, сорвавшаяся первой
% T     Момент начала движения первой МС (нужно ли?!)
% V     Напряжение в момент начала движения
% Окно поиска минимума
L = d.rate * 0.015;
% Определение моментов размыкания ГК
Open = zeros(1, 3);
for k=1:length(Open)
    Open(k) = d.Open{k}(1);
end
% Матрица с именами фаз
Phase = ['A' 'B' 'C'];
% Матрица с номерами фаз
Num = [1 2 3];
% Опредение номера первой сорвашейся МС
Num = Num(Open==min(Open));
% Опредение фазы первой сорвавщейся МС
F=Phase(Num);
% Массив пофазных Токов размагничивания
Ip = d.data( :, 2);
% Массив отсчетов времени (нужен ли?!)
t = d.data( :, 1);
% Определение момента размыкания первой МС
Open = Open(Num(1));
% Выделения части данных для разамкнувщейся фазы, до момента размыкания ГК
If = Ip(t<=Open,1);
% и за L(примерно 15 мс) отсчетов до этого
If = If(end-L+1:end);
% То же самое для времени
Tf = t(t<=Open);
Tf = Tf(end-L+1:end);
% Определение минимальной точки и соответствующего отсчета
[Ii, N ] = min(Ochistk(If)); %#ok;
% Определение момента времени
T = Tf(N);
% Индексирование солбца по минимуму тока
Ti = (t==T);
% создание пофазных токов
Ia = Ochistk(d.data(:,2));
% Ib = Ochistk(d.data(:,3));
% Ic = Ochistk(d.data(:,4));
% Определение пофазных токов рамагничивания
Iph = -1*Ia(Ti);
% Определение суммарного тока размагничивания
II = sum(Iph);
% Определения напряжения
V = Ochistk(d.data(:,7));
% Напряжение в момент размагничивания
V = -V(Ti);
end
%% Поиск максимума осцилограмм
function Tm = FindMax(T, Ip, On, Off, Start)
% Функция поиска максимумов на оссцилограмме
% Выходные данные - два максимума Tm
% Входные данные:
%   T       - Вектор времени
%   Ip      - Вектор тока
%   On      - Моменты включения напряжения
%   Off     - Моменты отключения напряжения
%   Start   - Стартовая точка
% Введение поправки на стратовую точку
T = T - Start;
% % Очистка от высокочастотных шумов
% Ip = Ochistk(Ip);
% Сглаживание усреднением
Ip = smooth(Ip);
% Выделение осцилограм второго импулься включения, искомые точки находятся
% там
% Для тока
Ip=Ip(T>On(2));
% Для времени
T=T(T>On(2));
% Тоже с друго стороны
Ip=Ip(T<Off(2));
% ТОже с другой стороны
T=T(T<Off(2));
% Сглаживание первой производной тока
dIp = smooth([0;diff(Ip)],20);
% Вторая производная тока
ddIp = diff([0;dIp]);
% Перемножения производной на саму себя со сдвигом 1 для определения точек
% пересечения нуля
dIp = [0;dIp(1:end-1)].*dIp;
% Выделение точек пересечения нуля
Tp = T(dIp <= 0);
% Выделение точек, разница между которыми больше 1 мс
Tp = Tp(diff([0;Tp])>1e-3);
% Создание пустого вектора для второй производной тока, соответствующей
% пересечению нуля первой производной
dTp = zeros(size(Tp));
% Получение значения второй производной в момент пересечения нуля первой
% производной. Если втора я производная меньше нуля - значит максимум
for k=1:length(Tp)
    dTp(k)=ddIp(T==Tp(k));
end
% Выделение максимумов от минимумов по второй производной
Tm = Tp(dTp<=0);
% Максимум должен быть позже 1 мс после второго включения
Tm = Tm(Tm>On(2)+1e-3);
% Вибираеться первая и последня точка максимумов
Tm = [Tm(1);Tm(end)];
end
%% Калибровка нуля
function IZa = ZerroCalibrate(Oscill,Start)
% Калибровка нуля токовых каналов
% Вектор времени
T = Oscill(:, 1);
T = T(T < Start);
T = length(T);
Z = Oscill(1:T, 2:end);
IZ = sum(Z)/T;
IZa = IZ(1);
end